#!/usr/bin/env python3

"""
Maze Solver Node for ROS 2 Humble
STRONG OUTWARD BIAS: Heavily prioritizes exploring away from start
"""

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.duration import Duration
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Point, Twist
from nav_msgs.msg import OccupancyGrid, Odometry
from sensor_msgs.msg import LaserScan
from action_msgs.msg import GoalStatus
import numpy as np
from scipy.ndimage import binary_dilation
import math
import random
import time

class MazeSolver(Node):
    def __init__(self):
        super().__init__('maze_solver')
        
        # Parameters
        self.declare_parameter('goal_tolerance', 0.15)
        self.declare_parameter('frontier_min_size', 5)
        self.declare_parameter('exploration_interval', 12.0)
        self.declare_parameter('initial_rotation_time', 20.0)
        self.declare_parameter('min_frontier_distance', 0.5)
        
        # LIDAR-based exit detection parameters
        self.declare_parameter('exit_detection_range', 2.5)
        self.declare_parameter('exit_detection_angle', 120.0)
        self.declare_parameter('exit_min_distance_from_start', 2.0)
        self.declare_parameter('outward_exploration_weight', 10.0)
        self.declare_parameter('min_frontier_distance_from_start', 0.3)
        
        self.goal_tolerance = self.get_parameter('goal_tolerance').value
        self.frontier_min_size = self.get_parameter('frontier_min_size').value
        self.exploration_interval = self.get_parameter('exploration_interval').value
        self.initial_rotation_time = self.get_parameter('initial_rotation_time').value
        self.min_frontier_distance = self.get_parameter('min_frontier_distance').value
        self.exit_detection_range = self.get_parameter('exit_detection_range').value
        self.exit_detection_angle = self.get_parameter('exit_detection_angle').value
        self.exit_min_distance_from_start = self.get_parameter('exit_min_distance_from_start').value
        self.outward_weight = self.get_parameter('outward_exploration_weight').value
        self.min_frontier_distance_from_start = self.get_parameter('min_frontier_distance_from_start').value
        
        # State variables
        self.current_pose = None
        self.map_data = None
        self.map_info = None
        self.exploring = True
        self.exit_found = False
        self.exit_position = None
        self.start_position = None
        
        # Laser scan data
        self.latest_scan = None
        self.scan_ranges = None
        
        # Initial mapping state
        self.initial_mapping_done = False
        self.initial_mapping_start_time = None
        self.last_log_time = 0
        
        # Frontier tracking
        self.last_frontier_target = None
        self.same_frontier_count = 0
        self.stuck_threshold = 4
        
        # Failed frontiers tracking
        self.failed_frontiers = []
        self.max_failed_attempts = 3
        
        # Random exploration failure tracking
        self.consecutive_random_failures = 0
        self.max_random_failures = 3
        
        # Desperation mode
        self.desperation_mode = False
        
        # Goal handle and state tracking
        self._current_goal_handle = None
        self._goal_active = False
        self._goal_start_time = None
        self._last_goal_status = None
        
        # Publishers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        
        # Subscribers
        self.map_sub = self.create_subscription(
            OccupancyGrid,
            '/map',
            self.map_callback,
            10
        )
        
        self.odom_sub = self.create_subscription(
            Odometry,
            '/odom',
            self.odom_callback,
            10
        )
        
        self.scan_sub = self.create_subscription(
            LaserScan,
            '/scan',
            self.scan_callback,
            10
        )
        
        # Action client for Nav2
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        
        # Timers
        self.initial_mapping_timer = self.create_timer(
            0.1,
            self.initial_mapping_callback
        )
        
        self.exploration_timer = self.create_timer(
            self.exploration_interval,
            self.exploration_callback
        )
        
        self.get_logger().info('Maze Solver Node initialized (STRONG OUTWARD BIAS)')
        self.get_logger().info('=' * 60)
        self.get_logger().info('PHASE 1: Initial 360¬∞ rotation for map building')
        self.get_logger().info(f'Duration: {self.initial_rotation_time} seconds')
        self.get_logger().info(f'Outward exploration weight: {self.outward_weight}')
        self.get_logger().info('=' * 60)
    
    def initial_mapping_callback(self):
        """Rotate robot initially to build a basic map"""
        if self.initial_mapping_done:
            self.initial_mapping_timer.cancel()
            return
        
        if self.initial_mapping_start_time is None:
            self.initial_mapping_start_time = self.get_clock().now()
        
        elapsed = (self.get_clock().now() - self.initial_mapping_start_time).nanoseconds / 1e9
        
        if elapsed < self.initial_rotation_time:
            twist = Twist()
            twist.angular.z = 0.5
            self.cmd_vel_pub.publish(twist)
            
            if int(elapsed) >= self.last_log_time + 5:
                self.last_log_time = int(elapsed)
                progress = (elapsed / self.initial_rotation_time) * 100
                self.get_logger().info(
                    f'Initial mapping progress: {int(elapsed)}s / {int(self.initial_rotation_time)}s '
                    f'({progress:.0f}%)'
                )
        else:
            twist = Twist()
            twist.angular.z = 0.0
            self.cmd_vel_pub.publish(twist)
            
            self.initial_mapping_done = True
            self.get_logger().info('=' * 60)
            self.get_logger().info('‚úì PHASE 1 COMPLETE: Initial mapping done!')
            self.get_logger().info('=' * 60)
            self.get_logger().info('PHASE 2: Starting frontier-based maze exploration...')
            self.get_logger().info('Prioritizing areas FAR from start position')
            self.get_logger().info('=' * 60)
    
    def odom_callback(self, msg):
        """Update current robot position"""
        self.current_pose = msg.pose.pose
        
        if self.start_position is None:
            self.start_position = (
                msg.pose.pose.position.x,
                msg.pose.pose.position.y
            )
            self.get_logger().info(
                f'Start position recorded: ({self.start_position[0]:.3f}, '
                f'{self.start_position[1]:.3f})'
            )
    
    def map_callback(self, msg):
        """Process updated map from SLAM"""
        self.map_data = np.array(msg.data).reshape((msg.info.height, msg.info.width))
        self.map_info = msg.info
    
    def scan_callback(self, msg):
        """Process laser scan data for obstacle detection and exit detection"""
        self.latest_scan = msg
        self.scan_ranges = np.array(msg.ranges)
        self.scan_ranges[np.isinf(self.scan_ranges)] = msg.range_max
        
        # LIDAR-based exit detection (ONLY exit condition)
        if self.initial_mapping_done and not self.exit_found:
            self.check_for_exit_lidar()
    
    def check_for_exit_lidar(self):
        """Detect exit using LIDAR - ONLY exit detection method"""
        if self.latest_scan is None or self.scan_ranges is None:
            return False
        
        if self.current_pose is None or self.start_position is None:
            return False
        
        current_x = self.current_pose.position.x
        current_y = self.current_pose.position.y
        distance_from_start = math.sqrt(
            (current_x - self.start_position[0])**2 + 
            (current_y - self.start_position[1])**2
        )
        
        if distance_from_start < self.exit_min_distance_from_start:
            return False
        
        half_angle = self.exit_detection_angle / 2.0
        num_readings = len(self.scan_ranges)
        indices_per_degree = num_readings / 360.0
        half_range_indices = int(half_angle * indices_per_degree)
        
        clear_readings = 0
        total_readings = 0
        
        for i in range(num_readings - half_range_indices, num_readings):
            if not np.isnan(self.scan_ranges[i]) and not np.isinf(self.scan_ranges[i]):
                total_readings += 1
                if self.scan_ranges[i] >= self.exit_detection_range:
                    clear_readings += 1
        
        for i in range(0, half_range_indices):
            if not np.isnan(self.scan_ranges[i]) and not np.isinf(self.scan_ranges[i]):
                total_readings += 1
                if self.scan_ranges[i] >= self.exit_detection_range:
                    clear_readings += 1
        
        if total_readings == 0:
            return False
        
        clear_percentage = (clear_readings / total_readings) * 100.0
        
        if clear_percentage > 80.0:
            self.exit_found = True
            
            orientation = self.current_pose.orientation
            siny_cosp = 2 * (orientation.w * orientation.z + orientation.x * orientation.y)
            cosy_cosp = 1 - 2 * (orientation.y * orientation.y + orientation.z * orientation.z)
            yaw = math.atan2(siny_cosp, cosy_cosp)
            
            exit_distance = 3.0
            self.exit_position = (
                current_x + exit_distance * math.cos(yaw),
                current_y + exit_distance * math.sin(yaw)
            )
            
            self.get_logger().info('=' * 60)
            self.get_logger().info('üéØ EXIT DETECTED VIA LIDAR!')
            self.get_logger().info(f'Clear path: {clear_percentage:.1f}%')
            self.get_logger().info(f'Distance from start: {distance_from_start:.2f}m')
            self.get_logger().info('=' * 60)
            
            self.navigate_to_exit()
            return True
        
        return False
    
    def is_goal_in_map_bounds(self, goal_x, goal_y):
        """Check if goal is within map bounds"""
        if self.map_info is None:
            return False
        
        mx = int((goal_x - self.map_info.origin.position.x) / self.map_info.resolution)
        my = int((goal_y - self.map_info.origin.position.y) / self.map_info.resolution)
        
        # FIXED: Use smaller margin, especially in desperation mode
        if self.desperation_mode:
            margin = 1  # Very lenient in desperation
        else:
            margin = 2  # Reduced from max(5, int(0.3 / self.map_info.resolution))
    
        is_valid = (margin <= mx < (self.map_info.width - margin) and 
               margin <= my < (self.map_info.height - margin))
        
        if not is_valid:
            self.get_logger().debug(
                f'Goal ({goal_x:.2f}, {goal_y:.2f}) out of bounds: '
                f'mx={mx}, my={my}, width={self.map_info.width}, height={self.map_info.height}'
            )
        
        return is_valid
    
    def is_frontier_failed(self, frontier_x, frontier_y):
        """Check if frontier has failed too many times"""
        # In desperation mode, ignore failed frontier list
        if self.desperation_mode:
            return False
            
        for (fx, fy, count) in self.failed_frontiers:
            distance = math.sqrt((fx - frontier_x)**2 + (fy - frontier_y)**2)
            if distance < 0.3:
                return count >= self.max_failed_attempts
        return False
    
    def mark_frontier_failed(self, frontier_x, frontier_y):
        """Mark a frontier as failed"""
        for i, (fx, fy, count) in enumerate(self.failed_frontiers):
            distance = math.sqrt((fx - frontier_x)**2 + (fy - frontier_y)**2)
            if distance < 0.3:
                self.failed_frontiers[i] = (fx, fy, count + 1)
                return
        
        self.failed_frontiers.append((frontier_x, frontier_y, 1))
    
    def exploration_callback(self):
        """Main exploration loop"""
        if not self.initial_mapping_done:
            return
        
        if self.exit_found:
            return
        
        if self.map_data is None or self.current_pose is None:
            return
        
        if self._goal_active:
            if self._goal_start_time is not None:
                elapsed = (self.get_clock().now() - self._goal_start_time).nanoseconds / 1e9
                if elapsed > 60.0:
                    self.get_logger().warn('‚è±Ô∏è Goal timeout - cancelling')
                    if self._current_goal_handle is not None:
                        self._current_goal_handle.cancel_goal_async()
                    self._goal_active = False
                else:
                    return
            else:
                return
        
        frontiers = self.find_frontiers()
        
        if len(frontiers) == 0:
            self.get_logger().warn('No frontiers - random exploration')
            self.random_exploration()
            return
        
        target_frontier = self.select_best_frontier_with_filter(frontiers)
        
        if target_frontier is None:
            self.get_logger().warn('No valid frontiers after filtering')
            
            # Log why frontiers were filtered
            for fx, fy, size in frontiers:
                failed = self.is_frontier_failed(fx, fy)
                distance = math.sqrt((fx - self.current_pose.position.x)**2 + 
                                   (fy - self.current_pose.position.y)**2)
                in_bounds = self.is_goal_in_map_bounds(fx, fy)
                
                if self.start_position:
                    dist_from_start = math.sqrt(
                        (fx - self.start_position[0])**2 + 
                        (fy - self.start_position[1])**2
                    )
                else:
                    dist_from_start = 0
                
                self.get_logger().info(
                    f'  Frontier ({fx:.2f}, {fy:.2f}): '
                    f'failed={failed}, dist_robot={distance:.2f}m, '
                    f'dist_start={dist_from_start:.2f}m, in_bounds={in_bounds}'
                )
            
            # Enter desperation mode and try again
            if not self.desperation_mode:
                self.get_logger().warn('üíÄ Entering DESPERATION MODE - ignoring failed frontiers')
                self.desperation_mode = True
                target_frontier = self.select_best_frontier_with_filter(frontiers)
            
            if target_frontier is None:
                self.random_exploration()
                return
        
        self.consecutive_random_failures = 0
        
        if self.last_frontier_target is not None:
            distance_to_last = math.sqrt(
                (target_frontier[0] - self.last_frontier_target[0])**2 +
                (target_frontier[1] - self.last_frontier_target[1])**2
            )
            
            if distance_to_last < 0.3:
                self.same_frontier_count += 1
                
                if self.same_frontier_count >= self.stuck_threshold:
                    self.mark_frontier_failed(target_frontier[0], target_frontier[1])
                    self.same_frontier_count = 0
                    self.last_frontier_target = None
                    self.random_exploration()
                    return
            else:
                self.same_frontier_count = 0
        
        self.last_frontier_target = target_frontier
        self.navigate_to_frontier(target_frontier)
    
    def find_frontiers(self):
        """Find frontier cells"""
        if self.map_data is None:
            return []
        
        free_cells = (self.map_data == 0)
        unknown_cells = (self.map_data == -1)
        dilated_free = binary_dilation(free_cells, iterations=1)
        frontiers = unknown_cells & dilated_free
        
        from scipy.ndimage import label
        labeled_frontiers, num_features = label(frontiers)
        
        frontier_centroids = []
        
        for i in range(1, num_features + 1):
            region = (labeled_frontiers == i)
            size = np.sum(region)
            
            if size >= self.frontier_min_size:
                coords = np.where(region)
                centroid_y = int(np.mean(coords[0]))
                centroid_x = int(np.mean(coords[1]))
                
                world_x = centroid_x * self.map_info.resolution + self.map_info.origin.position.x
                world_y = centroid_y * self.map_info.resolution + self.map_info.origin.position.y
                
                frontier_centroids.append((world_x, world_y, size))
        
        if len(frontier_centroids) > 0:
            self.get_logger().info(f'Found {len(frontier_centroids)} frontiers')
        
        return frontier_centroids
    
    def select_best_frontier_with_filter(self, frontiers):
        """Select best frontier - HEAVILY prioritize distance from start"""
        if not frontiers or self.current_pose is None:
            return None
        
        best_frontier = None
        best_score = float('-inf')
        
        current_x = self.current_pose.position.x
        current_y = self.current_pose.position.y
        
        valid_frontiers = []
        
        for fx, fy, size in frontiers:
            if self.is_frontier_failed(fx, fy):
                continue
            
            distance_to_robot = math.sqrt((fx - current_x)**2 + (fy - current_y)**2)
            if distance_to_robot < self.min_frontier_distance:
                continue
            
            if not self.is_goal_in_map_bounds(fx, fy):
                continue
            
            # Filter out frontiers too close to start (unless in desperation mode)
            if self.start_position and not self.desperation_mode:
                distance_from_start = math.sqrt(
                    (fx - self.start_position[0])**2 + 
                    (fy - self.start_position[1])**2
                )
                if distance_from_start < self.min_frontier_distance_from_start:
                    self.get_logger().debug(
                        f'Frontier ({fx:.2f}, {fy:.2f}) too close to start ({distance_from_start:.2f}m)'
                    )
                    continue
            
            valid_frontiers.append((fx, fy, size, distance_to_robot))
        
        if not valid_frontiers:
            return None
        
        for fx, fy, size, distance_to_robot in valid_frontiers:
            if self.start_position is not None:
                distance_from_start = math.sqrt(
                    (fx - self.start_position[0])**2 + 
                    (fy - self.start_position[1])**2
                )
            else:
                distance_from_start = 0.0
            
            # AGGRESSIVE OUTWARD SCORING:
            # 1. Base score from frontier size and proximity to robot
            base_score = size / (distance_to_robot + 0.5)
            
            # 2. EXPONENTIAL boost based on distance from start
            # This creates a VERY strong preference for far frontiers
            outward_multiplier = math.pow(1.0 + distance_from_start, self.outward_weight / 5.0)
            
            # 3. Additional linear boost
            outward_bonus = distance_from_start * self.outward_weight
            
            # Final score heavily favors distant frontiers
            score = base_score * outward_multiplier + outward_bonus
            
            if score > best_score:
                best_score = score
                best_frontier = (fx, fy)
        
        if best_frontier and self.start_position:
            dist_from_start = math.sqrt(
                (best_frontier[0] - self.start_position[0])**2 + 
                (best_frontier[1] - self.start_position[1])**2
            )
            dist_from_robot = math.sqrt(
                (best_frontier[0] - current_x)**2 + 
                (best_frontier[1] - current_y)**2
            )
            self.get_logger().info('=' * 60)
            self.get_logger().info(
                f'‚úì SELECTED FRONTIER: ({best_frontier[0]:.2f}, {best_frontier[1]:.2f})'
            )
            self.get_logger().info(f'  Distance from START: {dist_from_start:.2f}m')
            self.get_logger().info(f'  Distance from ROBOT: {dist_from_robot:.2f}m')
            self.get_logger().info(f'  Score: {best_score:.2f}')
            self.get_logger().info('=' * 60)
        
        return best_frontier
    
    def navigate_to_frontier(self, frontier):
        """Send navigation goal"""
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = frontier[0]
        goal_msg.pose.pose.position.y = frontier[1]
        goal_msg.pose.pose.orientation.w = 1.0
        
        self._goal_start_time = self.get_clock().now()
        self._goal_active = True
        
        self.get_logger().info(f'‚Üí Navigating to frontier at ({frontier[0]:.2f}, {frontier[1]:.2f})')
        
        self.nav_client.wait_for_server()
        future = self.nav_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)
        future.add_done_callback(self._goal_response_callback)
    
    def feedback_callback(self, feedback_msg):
        pass
    
    def _goal_response_callback(self, future):
        goal_handle = future.result()
        
        if not goal_handle.accepted:
            self.get_logger().warn('Goal rejected!')
            self._current_goal_handle = None
            self._goal_active = False
            return
        
        self.get_logger().info('‚úì Goal accepted')
        self._current_goal_handle = goal_handle
        
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self._goal_result_callback)
    
    def _goal_result_callback(self, future):
        result = future.result()
        status = result.status
        
        self._goal_active = False
        self._current_goal_handle = None
        
        if status == GoalStatus.STATUS_SUCCEEDED:
            self.get_logger().info('‚úì Goal reached!')
            self.same_frontier_count = 0
            self.consecutive_random_failures = 0
            self.desperation_mode = False  # Reset desperation
        elif status == GoalStatus.STATUS_ABORTED:
            self.get_logger().warn('‚ö†Ô∏è Goal aborted')
        elif status == GoalStatus.STATUS_CANCELED:
            self.get_logger().warn('‚ö†Ô∏è Goal cancelled')
    
    def random_exploration(self):
        """Random exploration - also biased outward"""
        if self.current_pose is None or self.map_info is None or self.map_data is None:
            return
        
        max_attempts = 40
        
        # Adaptive margin based on desperation
        if self.desperation_mode:
            margin = 1  # FIXED: Even more aggressive
            self.get_logger().warn(f'üî• DESPERATION MODE: using margin={margin}')
        elif self.consecutive_random_failures >= 2:
            margin = 3  # FIXED: Reduced from 5
            self.get_logger().warn(f'Using reduced margin={margin}')
        else:
            margin = 5  # FIXED: Reduced from 8
        
        # Calculate direction away from start for bias
        if self.start_position:
            away_from_start_x = self.current_pose.position.x - self.start_position[0]
            away_from_start_y = self.current_pose.position.y - self.start_position[1]
            dist = math.sqrt(away_from_start_x**2 + away_from_start_y**2)
            if dist > 0.1:
                away_from_start_x /= dist
                away_from_start_y /= dist
            else:
                away_from_start_x = 0
                away_from_start_y = 0
        else:
            away_from_start_x = 0
            away_from_start_y = 0
        
        for attempt in range(max_attempts):
            # Bias angle selection toward direction away from start
            if random.random() < 0.7 and dist > 0.1:  # 70% of time, prefer outward direction
                # Random angle around the "away from start" direction (¬±90¬∞)
                away_angle = math.atan2(away_from_start_y, away_from_start_x)
                angle = away_angle + random.uniform(-math.pi/2, math.pi/2)
            else:
                angle = random.uniform(0, 2 * math.pi)
            
            # FIXED: Increased minimum distance from 0.3 to 0.5, max from 1.2 to 1.5
            distance = random.uniform(0.5, 1.5)
            
            goal_x = self.current_pose.position.x + distance * math.cos(angle)
            goal_y = self.current_pose.position.y + distance * math.sin(angle)
            
            mx = int((goal_x - self.map_info.origin.position.x) / self.map_info.resolution)
            my = int((goal_y - self.map_info.origin.position.y) / self.map_info.resolution)
            
            if not (margin <= mx < (self.map_info.width - margin) and 
                    margin <= my < (self.map_info.height - margin)):
                continue
            
            if self.map_data[my, mx] != 0:
                continue
            
            free_space_count = 0
            total_checks = 0
            check_radius = 2
            
            for dy in range(-check_radius, check_radius + 1):
                for dx in range(-check_radius, check_radius + 1):
                    check_x = mx + dx
                    check_y = my + dy
                    
                    if (0 <= check_x < self.map_info.width and 
                        0 <= check_y < self.map_info.height):
                        total_checks += 1
                        if self.map_data[check_y, check_x] == 0:
                            free_space_count += 1
            
            threshold = 0.4 if self.desperation_mode else 0.6
            if total_checks > 0 and (free_space_count / total_checks) < threshold:
                continue
            
            # Calculate how far this random goal is from start
            if self.start_position:
                goal_dist_from_start = math.sqrt(
                    (goal_x - self.start_position[0])**2 + 
                    (goal_y - self.start_position[1])**2
                )
            else:
                goal_dist_from_start = 0
            
            self.get_logger().info(
                f'üîÄ Random to ({goal_x:.2f}, {goal_y:.2f}) '
                f'[dist from start: {goal_dist_from_start:.2f}m, dist from robot: {distance:.2f}m, attempt {attempt+1}]'
            )
            
            goal_msg = NavigateToPose.Goal()
            goal_msg.pose.header.frame_id = 'map'
            goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
            goal_msg.pose.pose.position.x = goal_x
            goal_msg.pose.pose.position.y = goal_y
            goal_msg.pose.pose.orientation.w = 1.0
            
            self._goal_start_time = self.get_clock().now()
            self._goal_active = True
            
            self.nav_client.wait_for_server()
            future = self.nav_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)
            future.add_done_callback(self._goal_response_callback)
            
            self.consecutive_random_failures = 0
            return
        
        self.consecutive_random_failures += 1
        self.get_logger().error(
            f'‚ùå No valid random goal after {max_attempts} attempts! '
            f'({self.consecutive_random_failures}/{self.max_random_failures})'
        )
        
        if self.consecutive_random_failures >= self.max_random_failures:
            if not self.desperation_mode:
                self.get_logger().warn('üíÄ Entering DESPERATION MODE - clearing failed frontiers')
                self.desperation_mode = True
                self.failed_frontiers = []
                self.consecutive_random_failures = 0
    
    def navigate_to_exit(self):
        """Navigate to exit"""
        if self.exit_position is None:
            return
        
        self.exploring = False
        self.exploration_timer.cancel()
        
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = self.exit_position[0]
        goal_msg.pose.pose.position.y = self.exit_position[1]
        goal_msg.pose.pose.orientation.w = 1.0
        
        self.get_logger().info('=' * 60)
        self.get_logger().info('PHASE 3: NAVIGATING TO EXIT!')
        self.get_logger().info(f'Exit: ({self.exit_position[0]:.2f}, {self.exit_position[1]:.2f})')
        self.get_logger().info('=' * 60)
        
        self._goal_active = True
        self._goal_start_time = self.get_clock().now()
        
        self.nav_client.wait_for_server()
        send_goal_future = self.nav_client.send_goal_async(goal_msg)
        send_goal_future.add_done_callback(self.goal_response_callback)
    
    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error('‚ùå Goal rejected')
            self._goal_active = False
            return
        
        self.get_logger().info('‚úì Goal accepted')
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.goal_result_callback)
    
    def goal_result_callback(self, future):
        self._goal_active = False
        self.get_logger().info('=' * 60)
        self.get_logger().info('üéâ MAZE SOLVED! üéâ')
        self.get_logger().info('=' * 60)


def main(args=None):
    rclpy.init(args=args)
    maze_solver = MazeSolver()
    
    try:
        rclpy.spin(maze_solver)
    except KeyboardInterrupt:
        pass
    finally:
        maze_solver.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
